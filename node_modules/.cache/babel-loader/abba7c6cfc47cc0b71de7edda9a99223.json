{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/Bhargab kalita/Downloads/DAO/DAO/PROJECTDAO/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/Bhargab kalita/Downloads/DAO/DAO/PROJECTDAO/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"C:/Users/Bhargab kalita/Downloads/DAO/DAO/PROJECTDAO/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Bhargab kalita/Downloads/DAO/DAO/PROJECTDAO/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"C:/Users/Bhargab kalita/Downloads/DAO/DAO/PROJECTDAO/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"C:/Users/Bhargab kalita/Downloads/DAO/DAO/PROJECTDAO/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Bhargab kalita/Downloads/DAO/DAO/PROJECTDAO/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { SafeEventEmitter } from '@toruslabs/openlogin-jrpc';\nimport { ADAPTER_STATUS, CHAIN_NAMESPACES, WalletInitializationError, storageAvailable, getChainConfig, ADAPTER_NAMESPACES, WalletLoginError, ADAPTER_EVENTS } from '@web3auth/base';\nimport log from 'loglevel';\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nvar ADAPTER_CACHE_KEY = \"Web3Auth-cachedAdapter\";\n\nvar Web3AuthCore = /*#__PURE__*/function (_SafeEventEmitter) {\n  _inherits(Web3AuthCore, _SafeEventEmitter);\n\n  var _super = _createSuper(Web3AuthCore);\n\n  function Web3AuthCore(options) {\n    var _this;\n\n    _classCallCheck(this, Web3AuthCore);\n\n    var _options$chainConfig, _options$chainConfig2, _options$chainConfig3, _options$chainConfig4;\n\n    _this = _super.call(this);\n\n    _defineProperty(_assertThisInitialized(_this), \"coreOptions\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"connectedAdapterName\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"status\", ADAPTER_STATUS.NOT_READY);\n\n    _defineProperty(_assertThisInitialized(_this), \"cachedAdapter\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"walletAdapters\", {});\n\n    if (!((_options$chainConfig = options.chainConfig) !== null && _options$chainConfig !== void 0 && _options$chainConfig.chainNamespace) || !Object.values(CHAIN_NAMESPACES).includes((_options$chainConfig2 = options.chainConfig) === null || _options$chainConfig2 === void 0 ? void 0 : _options$chainConfig2.chainNamespace)) throw WalletInitializationError.invalidParams(\"Please provide a valid chainNamespace in chainConfig\");\n    _this.cachedAdapter = storageAvailable(\"sessionStorage\") ? window.sessionStorage.getItem(ADAPTER_CACHE_KEY) : null;\n    _this.coreOptions = _objectSpread(_objectSpread({}, options), {}, {\n      chainConfig: _objectSpread(_objectSpread({}, getChainConfig((_options$chainConfig3 = options.chainConfig) === null || _options$chainConfig3 === void 0 ? void 0 : _options$chainConfig3.chainNamespace, (_options$chainConfig4 = options.chainConfig) === null || _options$chainConfig4 === void 0 ? void 0 : _options$chainConfig4.chainId)), options.chainConfig)\n    });\n    _this.subscribeToAdapterEvents = _this.subscribeToAdapterEvents.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(Web3AuthCore, [{\n    key: \"provider\",\n    get: function get() {\n      if (this.status === ADAPTER_STATUS.CONNECTED && this.connectedAdapterName) {\n        var adapter = this.walletAdapters[this.connectedAdapterName];\n        return adapter.provider;\n      }\n\n      return null;\n    },\n    set: function set(_) {\n      throw new Error(\"Not implemented\");\n    }\n  }, {\n    key: \"init\",\n    value: function () {\n      var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _this2 = this;\n\n        var initPromises;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                initPromises = Object.keys(this.walletAdapters).map(function (adapterName) {\n                  _this2.subscribeToAdapterEvents(_this2.walletAdapters[adapterName]); // if adapter doesn't have any chain config yet thn set it based on provided namespace and chainId.\n                  // if no chainNamespace or chainId is being provided, it will connect with mainnet.\n\n\n                  if (!_this2.walletAdapters[adapterName].chainConfigProxy) {\n                    var providedChainConfig = _this2.coreOptions.chainConfig;\n                    if (!providedChainConfig.chainNamespace) throw WalletInitializationError.invalidParams(\"Please provide chainNamespace in chainConfig\");\n\n                    var chainConfig = _objectSpread(_objectSpread({}, getChainConfig(providedChainConfig.chainNamespace, providedChainConfig.chainId)), providedChainConfig);\n\n                    _this2.walletAdapters[adapterName].setChainConfig(chainConfig);\n                  }\n\n                  return _this2.walletAdapters[adapterName].init({\n                    autoConnect: _this2.cachedAdapter === adapterName\n                  }).catch(function (e) {\n                    return log.error(e);\n                  });\n                });\n                this.status = ADAPTER_STATUS.READY;\n                _context.next = 4;\n                return Promise.all(initPromises);\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function init() {\n        return _init.apply(this, arguments);\n      }\n\n      return init;\n    }()\n  }, {\n    key: \"configureAdapter\",\n    value: function configureAdapter(adapter) {\n      this.checkInitRequirements();\n      var providedChainConfig = this.coreOptions.chainConfig;\n      if (!providedChainConfig.chainNamespace) throw WalletInitializationError.invalidParams(\"Please provide chainNamespace in chainConfig\");\n      var adapterAlreadyExists = this.walletAdapters[adapter.name];\n      if (adapterAlreadyExists) throw WalletInitializationError.duplicateAdapterError(\"Wallet adapter for \".concat(adapter.name, \" already exists\"));\n      if (adapter.adapterNamespace !== ADAPTER_NAMESPACES.MULTICHAIN && adapter.adapterNamespace !== providedChainConfig.chainNamespace) throw WalletInitializationError.incompatibleChainNameSpace(\"This wallet adapter belongs to \".concat(adapter.adapterNamespace, \" which is incompatible with currently used namespace: \").concat(providedChainConfig.chainNamespace));\n\n      if (adapter.adapterNamespace === ADAPTER_NAMESPACES.MULTICHAIN && adapter.currentChainNamespace && providedChainConfig.chainNamespace !== adapter.currentChainNamespace) {\n        // chainConfig checks are already validated in constructor so using typecast is safe here.\n        adapter.setChainConfig(providedChainConfig);\n      }\n\n      this.walletAdapters[adapter.name] = adapter;\n      return this;\n    }\n  }, {\n    key: \"clearCache\",\n    value: function clearCache() {\n      if (!storageAvailable(\"sessionStorage\")) return;\n      window.sessionStorage.removeItem(ADAPTER_CACHE_KEY);\n      this.cachedAdapter = null;\n    }\n    /**\n     * Connect to a specific wallet adapter\n     * @param walletName - Key of the walletAdapter to use.\n     */\n\n  }, {\n    key: \"connectTo\",\n    value: function () {\n      var _connectTo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(walletName, loginParams) {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (this.walletAdapters[walletName]) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                throw WalletInitializationError.notFound(\"Please add wallet adapter for \".concat(walletName, \" wallet, before connecting\"));\n\n              case 2:\n                return _context2.abrupt(\"return\", this.walletAdapters[walletName].connect(loginParams));\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function connectTo(_x, _x2) {\n        return _connectTo.apply(this, arguments);\n      }\n\n      return connectTo;\n    }()\n  }, {\n    key: \"logout\",\n    value: function () {\n      var _logout = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var options,\n            _args3 = arguments;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                options = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {\n                  cleanup: false\n                };\n\n                if (!(this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName)) {\n                  _context3.next = 3;\n                  break;\n                }\n\n                throw WalletLoginError.notConnectedError(\"No wallet is connected\");\n\n              case 3:\n                _context3.next = 5;\n                return this.walletAdapters[this.connectedAdapterName].disconnect(options);\n\n              case 5:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function logout() {\n        return _logout.apply(this, arguments);\n      }\n\n      return logout;\n    }()\n  }, {\n    key: \"getUserInfo\",\n    value: function () {\n      var _getUserInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                log.debug(\"Getting user info\", this.status, this.connectedAdapterName);\n\n                if (!(this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName)) {\n                  _context4.next = 3;\n                  break;\n                }\n\n                throw WalletLoginError.notConnectedError(\"No wallet is connected\");\n\n              case 3:\n                return _context4.abrupt(\"return\", this.walletAdapters[this.connectedAdapterName].getUserInfo());\n\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function getUserInfo() {\n        return _getUserInfo.apply(this, arguments);\n      }\n\n      return getUserInfo;\n    }()\n  }, {\n    key: \"subscribeToAdapterEvents\",\n    value: function subscribeToAdapterEvents(walletAdapter) {\n      var _this3 = this;\n\n      walletAdapter.on(ADAPTER_EVENTS.CONNECTED, function (data) {\n        _this3.status = ADAPTER_STATUS.CONNECTED;\n        _this3.connectedAdapterName = data.adapter;\n\n        _this3.cacheWallet(data.adapter);\n\n        _this3.emit(ADAPTER_EVENTS.CONNECTED, _objectSpread({}, data));\n\n        log.debug(\"connected\", _this3.status, _this3.connectedAdapterName);\n      });\n      walletAdapter.on(ADAPTER_EVENTS.DISCONNECTED, function (data) {\n        // get back to ready state for rehydrating.\n        _this3.status = ADAPTER_STATUS.READY;\n\n        _this3.emit(ADAPTER_EVENTS.DISCONNECTED, data);\n\n        if (storageAvailable(\"sessionStorage\")) {\n          var cachedAdapter = window.sessionStorage.getItem(ADAPTER_CACHE_KEY);\n\n          if (_this3.connectedAdapterName === cachedAdapter) {\n            _this3.clearCache();\n          }\n        }\n\n        log.debug(\"disconnected\", _this3.status, _this3.connectedAdapterName);\n      });\n      walletAdapter.on(ADAPTER_EVENTS.CONNECTING, function (data) {\n        _this3.status = ADAPTER_STATUS.CONNECTING;\n\n        _this3.emit(ADAPTER_EVENTS.CONNECTING, data);\n\n        log.debug(\"connecting\", _this3.status, _this3.connectedAdapterName);\n      });\n      walletAdapter.on(ADAPTER_EVENTS.ERRORED, function (data) {\n        _this3.status = ADAPTER_STATUS.ERRORED;\n\n        _this3.clearCache();\n\n        _this3.emit(ADAPTER_EVENTS.ERRORED, data);\n\n        log.debug(\"errored\", _this3.status, _this3.connectedAdapterName);\n      });\n      walletAdapter.on(ADAPTER_EVENTS.ADAPTER_DATA_UPDATED, function (data) {\n        log.debug(\"adapter data updated\", data);\n\n        _this3.emit(ADAPTER_EVENTS.ADAPTER_DATA_UPDATED, data);\n      });\n    }\n  }, {\n    key: \"checkInitRequirements\",\n    value: function checkInitRequirements() {\n      if (this.status === ADAPTER_STATUS.CONNECTING) throw WalletInitializationError.notReady(\"Already pending connection\");\n      if (this.status === ADAPTER_STATUS.CONNECTED) throw WalletInitializationError.notReady(\"Already connected\");\n      if (this.status === ADAPTER_STATUS.READY) throw WalletInitializationError.notReady(\"Adapter is already initialized\");\n    }\n  }, {\n    key: \"cacheWallet\",\n    value: function cacheWallet(walletName) {\n      if (!storageAvailable(\"sessionStorage\")) return;\n      window.sessionStorage.setItem(ADAPTER_CACHE_KEY, walletName);\n      this.cachedAdapter = walletName;\n    }\n  }]);\n\n  return Web3AuthCore;\n}(SafeEventEmitter);\n\nexport { Web3AuthCore };","map":{"version":3,"sources":["../src/core.ts"],"names":["ADAPTER_CACHE_KEY","Web3AuthCore","SafeEventEmitter","ADAPTER_STATUS","NOT_READY","constructor","options","Object","WalletInitializationError","storageAvailable","window","chainConfig","getChainConfig","provider","adapter","init","initPromises","adapterName","providedChainConfig","autoConnect","e","log","Promise","configureAdapter","adapterAlreadyExists","ADAPTER_NAMESPACES","clearCache","connectTo","logout","cleanup","WalletLoginError","getUserInfo","subscribeToAdapterEvents","walletAdapter","ADAPTER_EVENTS","data","cachedAdapter","checkInitRequirements","cacheWallet"],"mappings":"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","sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { SafeEventEmitter } from '@toruslabs/openlogin-jrpc';\nimport { ADAPTER_STATUS, CHAIN_NAMESPACES, WalletInitializationError, storageAvailable, getChainConfig, ADAPTER_NAMESPACES, WalletLoginError, ADAPTER_EVENTS } from '@web3auth/base';\nimport log from 'loglevel';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nconst ADAPTER_CACHE_KEY = \"Web3Auth-cachedAdapter\";\nclass Web3AuthCore extends SafeEventEmitter {\n  constructor(options) {\n    var _options$chainConfig, _options$chainConfig2, _options$chainConfig3, _options$chainConfig4;\n\n    super();\n\n    _defineProperty(this, \"coreOptions\", void 0);\n\n    _defineProperty(this, \"connectedAdapterName\", null);\n\n    _defineProperty(this, \"status\", ADAPTER_STATUS.NOT_READY);\n\n    _defineProperty(this, \"cachedAdapter\", null);\n\n    _defineProperty(this, \"walletAdapters\", {});\n\n    if (!((_options$chainConfig = options.chainConfig) !== null && _options$chainConfig !== void 0 && _options$chainConfig.chainNamespace) || !Object.values(CHAIN_NAMESPACES).includes((_options$chainConfig2 = options.chainConfig) === null || _options$chainConfig2 === void 0 ? void 0 : _options$chainConfig2.chainNamespace)) throw WalletInitializationError.invalidParams(\"Please provide a valid chainNamespace in chainConfig\");\n    this.cachedAdapter = storageAvailable(\"sessionStorage\") ? window.sessionStorage.getItem(ADAPTER_CACHE_KEY) : null;\n    this.coreOptions = _objectSpread(_objectSpread({}, options), {}, {\n      chainConfig: _objectSpread(_objectSpread({}, getChainConfig((_options$chainConfig3 = options.chainConfig) === null || _options$chainConfig3 === void 0 ? void 0 : _options$chainConfig3.chainNamespace, (_options$chainConfig4 = options.chainConfig) === null || _options$chainConfig4 === void 0 ? void 0 : _options$chainConfig4.chainId)), options.chainConfig)\n    });\n    this.subscribeToAdapterEvents = this.subscribeToAdapterEvents.bind(this);\n  }\n\n  get provider() {\n    if (this.status === ADAPTER_STATUS.CONNECTED && this.connectedAdapterName) {\n      const adapter = this.walletAdapters[this.connectedAdapterName];\n      return adapter.provider;\n    }\n\n    return null;\n  }\n\n  set provider(_) {\n    throw new Error(\"Not implemented\");\n  }\n\n  async init() {\n    const initPromises = Object.keys(this.walletAdapters).map(adapterName => {\n      this.subscribeToAdapterEvents(this.walletAdapters[adapterName]); // if adapter doesn't have any chain config yet thn set it based on provided namespace and chainId.\n      // if no chainNamespace or chainId is being provided, it will connect with mainnet.\n\n      if (!this.walletAdapters[adapterName].chainConfigProxy) {\n        const providedChainConfig = this.coreOptions.chainConfig;\n        if (!providedChainConfig.chainNamespace) throw WalletInitializationError.invalidParams(\"Please provide chainNamespace in chainConfig\");\n\n        const chainConfig = _objectSpread(_objectSpread({}, getChainConfig(providedChainConfig.chainNamespace, providedChainConfig.chainId)), providedChainConfig);\n\n        this.walletAdapters[adapterName].setChainConfig(chainConfig);\n      }\n\n      return this.walletAdapters[adapterName].init({\n        autoConnect: this.cachedAdapter === adapterName\n      }).catch(e => log.error(e));\n    });\n    this.status = ADAPTER_STATUS.READY;\n    await Promise.all(initPromises);\n  }\n\n  configureAdapter(adapter) {\n    this.checkInitRequirements();\n    const providedChainConfig = this.coreOptions.chainConfig;\n    if (!providedChainConfig.chainNamespace) throw WalletInitializationError.invalidParams(\"Please provide chainNamespace in chainConfig\");\n    const adapterAlreadyExists = this.walletAdapters[adapter.name];\n    if (adapterAlreadyExists) throw WalletInitializationError.duplicateAdapterError(\"Wallet adapter for \".concat(adapter.name, \" already exists\"));\n    if (adapter.adapterNamespace !== ADAPTER_NAMESPACES.MULTICHAIN && adapter.adapterNamespace !== providedChainConfig.chainNamespace) throw WalletInitializationError.incompatibleChainNameSpace(\"This wallet adapter belongs to \".concat(adapter.adapterNamespace, \" which is incompatible with currently used namespace: \").concat(providedChainConfig.chainNamespace));\n\n    if (adapter.adapterNamespace === ADAPTER_NAMESPACES.MULTICHAIN && adapter.currentChainNamespace && providedChainConfig.chainNamespace !== adapter.currentChainNamespace) {\n      // chainConfig checks are already validated in constructor so using typecast is safe here.\n      adapter.setChainConfig(providedChainConfig);\n    }\n\n    this.walletAdapters[adapter.name] = adapter;\n    return this;\n  }\n\n  clearCache() {\n    if (!storageAvailable(\"sessionStorage\")) return;\n    window.sessionStorage.removeItem(ADAPTER_CACHE_KEY);\n    this.cachedAdapter = null;\n  }\n  /**\n   * Connect to a specific wallet adapter\n   * @param walletName - Key of the walletAdapter to use.\n   */\n\n\n  async connectTo(walletName, loginParams) {\n    if (!this.walletAdapters[walletName]) throw WalletInitializationError.notFound(\"Please add wallet adapter for \".concat(walletName, \" wallet, before connecting\"));\n    return this.walletAdapters[walletName].connect(loginParams);\n  }\n\n  async logout() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      cleanup: false\n    };\n    if (this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName) throw WalletLoginError.notConnectedError(\"No wallet is connected\");\n    await this.walletAdapters[this.connectedAdapterName].disconnect(options);\n  }\n\n  async getUserInfo() {\n    log.debug(\"Getting user info\", this.status, this.connectedAdapterName);\n    if (this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName) throw WalletLoginError.notConnectedError(\"No wallet is connected\");\n    return this.walletAdapters[this.connectedAdapterName].getUserInfo();\n  }\n\n  subscribeToAdapterEvents(walletAdapter) {\n    walletAdapter.on(ADAPTER_EVENTS.CONNECTED, data => {\n      this.status = ADAPTER_STATUS.CONNECTED;\n      this.connectedAdapterName = data.adapter;\n      this.cacheWallet(data.adapter);\n      this.emit(ADAPTER_EVENTS.CONNECTED, _objectSpread({}, data));\n      log.debug(\"connected\", this.status, this.connectedAdapterName);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.DISCONNECTED, data => {\n      // get back to ready state for rehydrating.\n      this.status = ADAPTER_STATUS.READY;\n      this.emit(ADAPTER_EVENTS.DISCONNECTED, data);\n\n      if (storageAvailable(\"sessionStorage\")) {\n        const cachedAdapter = window.sessionStorage.getItem(ADAPTER_CACHE_KEY);\n\n        if (this.connectedAdapterName === cachedAdapter) {\n          this.clearCache();\n        }\n      }\n\n      log.debug(\"disconnected\", this.status, this.connectedAdapterName);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.CONNECTING, data => {\n      this.status = ADAPTER_STATUS.CONNECTING;\n      this.emit(ADAPTER_EVENTS.CONNECTING, data);\n      log.debug(\"connecting\", this.status, this.connectedAdapterName);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.ERRORED, data => {\n      this.status = ADAPTER_STATUS.ERRORED;\n      this.clearCache();\n      this.emit(ADAPTER_EVENTS.ERRORED, data);\n      log.debug(\"errored\", this.status, this.connectedAdapterName);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.ADAPTER_DATA_UPDATED, data => {\n      log.debug(\"adapter data updated\", data);\n      this.emit(ADAPTER_EVENTS.ADAPTER_DATA_UPDATED, data);\n    });\n  }\n\n  checkInitRequirements() {\n    if (this.status === ADAPTER_STATUS.CONNECTING) throw WalletInitializationError.notReady(\"Already pending connection\");\n    if (this.status === ADAPTER_STATUS.CONNECTED) throw WalletInitializationError.notReady(\"Already connected\");\n    if (this.status === ADAPTER_STATUS.READY) throw WalletInitializationError.notReady(\"Adapter is already initialized\");\n  }\n\n  cacheWallet(walletName) {\n    if (!storageAvailable(\"sessionStorage\")) return;\n    window.sessionStorage.setItem(ADAPTER_CACHE_KEY, walletName);\n    this.cachedAdapter = walletName;\n  }\n\n}\n\nexport { Web3AuthCore };\n//# sourceMappingURL=core.esm.js.map\n"]},"metadata":{},"sourceType":"module"}